/*
 * This file was automatically generated by EvoSuite
 * Fri Aug 24 12:05:37 GMT 2018
 */

package weka.filters.unsupervised.attribute;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.ArrayList;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.util.SystemInUtil;
import org.junit.runner.RunWith;
import weka.core.Attribute;
import weka.core.BinarySparseInstance;
import weka.core.Capabilities;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Range;
import weka.core.SparseInstance;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.Discretize;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class Discretize_ESTest extends Discretize_ESTest_scaffolding {

  /**
  //Test case number: 0
  /*Coverage entropy=2.4849066497880012
  */
  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Discretize discretize0 = new Discretize("BtGA.@V~y-IK");
      String[] stringArray0 = new String[5];
      stringArray0[0] = "BtGA.@V~y-IK";
      stringArray0[1] = "BtGA.@V~y-IK";
      stringArray0[2] = "BtGA.@V~y-IK";
      stringArray0[3] = "BtGA.@V~y-IK";
      stringArray0[4] = "BtGA.@V~y-IK";
      Filter.runFilter(discretize0, stringArray0);
      Filter.makeCopy(discretize0);
      discretize0.setIgnoreClass(true);
      discretize0.getRevision();
      // Undeclared exception!
      try { 
        discretize0.output();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output instance format defined
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  /**
  //Test case number: 1
  /*Coverage entropy=2.3978952727983707
  */
  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Discretize discretize0 = new Discretize(")s|Y)U-");
      discretize0.getAttributeIndices();
      discretize0.m_UseEqualFrequency = false;
      discretize0.m_MakeBinary = true;
      discretize0.setInvertSelection(true);
      discretize0.setFindNumBins(true);
      discretize0.setBins(89);
      discretize0.getBins();
      discretize0.attributeIndicesTipText();
      discretize0.getBinRangesString(89);
      discretize0.setOutputFormat();
      discretize0.makeBinaryTipText();
      assertEquals(89, discretize0.getBins());
  }

  /**
  //Test case number: 2
  /*Coverage entropy=1.945910149055313
  */
  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      discretize0.getInvertSelection();
      discretize0.getDesiredWeightOfInstancesPerInterval();
      discretize0.findNumBinsTipText();
      discretize0.attributeIndicesTipText();
      // Undeclared exception!
      try { 
        discretize0.calculateCutPointsByEqualWidthBinning((-1396));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 3
  /*Coverage entropy=1.7917594692280547
  */
  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      discretize0.setDesiredWeightOfInstancesPerInterval((-1743.89363283593));
      int[] intArray0 = new int[2];
      intArray0[0] = 2072;
      discretize0.m_DefaultCols = "    Instance\t\tresult;\n";
      intArray0[1] = (-690);
      discretize0.setAttributeIndicesArray(intArray0);
      discretize0.getUseBinNumbers();
      discretize0.setUseEqualFrequency(false);
      // Undeclared exception!
      try { 
        discretize0.setAttributeIndices((String) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Range", e);
      }
  }

  /**
  //Test case number: 4
  /*Coverage entropy=1.6094379124341005
  */
  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      discretize0.m_NumBins = (-1805);
      double[][] doubleArray0 = new double[5][6];
      double[] doubleArray1 = new double[5];
      doubleArray1[0] = (double) (-1805);
      doubleArray1[1] = (double) (-1805);
      doubleArray1[2] = (double) (-1805);
      doubleArray1[3] = (-342.201671628);
      doubleArray1[4] = (double) (-1805);
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[4];
      doubleArray2[0] = (-342.201671628);
      doubleArray2[1] = 1655.152;
      doubleArray2[2] = (double) (-1805);
      doubleArray2[3] = (double) (-1805);
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[0];
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[5];
      doubleArray4[0] = (double) (-1805);
      doubleArray4[1] = 1655.152;
      doubleArray4[2] = (-342.201671628);
      doubleArray4[3] = (-342.201671628);
      doubleArray4[4] = (double) (-1805);
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[0];
      doubleArray0[4] = doubleArray5;
      discretize0.m_CutPoints = doubleArray0;
      discretize0.m_DefaultCols = "";
      discretize0.globalInfo();
      discretize0.m_DesiredWeightOfInstancesPerInterval = 0.0;
      discretize0.setFindNumBins(false);
      // Undeclared exception!
      try { 
        discretize0.getBinRangesString((-461));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -461
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 5
  /*Coverage entropy=1.3862943611198906
  */
  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Discretize discretize0 = new Discretize("Sets the desired weight of instances per interval for equal-frequency binning.");
      discretize0.binsTipText();
      boolean boolean0 = false;
      // Undeclared exception!
      try { 
        discretize0.calculateCutPoints();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 6
  /*Coverage entropy=1.7917594692280547
  */
  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      Range range0 = new Range("\tSpecifies the (maximum) number of bins to divide numeric attributes into.\n\t(default = 10)");
      discretize0.m_DiscretizeCols = range0;
      int[] intArray0 = new int[1];
      range0.toString();
      discretize0.m_IgnoreClass = true;
      intArray0[0] = (-211);
      range0.toString();
      range0.setRanges("Strings: Specifies the (maximum) number of bins to divide numeric attributes into.\n\t(default = 10) \nInvert: false\nUpper limit has not been specified");
      range0.toDisplay();
      discretize0.setAttributeIndicesArray(intArray0);
      discretize0.useEqualFrequencyTipText();
      discretize0.globalInfo();
      discretize0.getMakeBinary();
      BinarySparseInstance binarySparseInstance0 = null;
      try {
        binarySparseInstance0 = new BinarySparseInstance((-2025));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.BinarySparseInstance", e);
      }
  }

  /**
  //Test case number: 7
  /*Coverage entropy=2.772588722239781
  */
  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      discretize0.getUseEqualFrequency();
      double[][] doubleArray0 = new double[9][8];
      double[] doubleArray1 = new double[0];
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[8];
      doubleArray2[0] = 2.0;
      doubleArray2[1] = (-2083.37);
      doubleArray2[2] = 2460.510197234556;
      doubleArray2[3] = 1794.63394275;
      doubleArray2[4] = 395.9359308698316;
      doubleArray2[5] = 0.0;
      doubleArray2[6] = 3138.168325;
      doubleArray2[7] = 1.7976931348623157E308;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[2];
      doubleArray3[0] = 1794.63394275;
      doubleArray3[1] = 0.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[4];
      doubleArray4[0] = 2460.510197234556;
      doubleArray4[1] = 2460.510197234556;
      doubleArray4[2] = (-2083.37);
      doubleArray4[3] = 2.0;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[4];
      doubleArray5[0] = 395.9359308698316;
      doubleArray5[1] = (-2083.37);
      doubleArray5[2] = 395.9359308698316;
      doubleArray5[3] = 1.7976931348623157E308;
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[8];
      doubleArray6[0] = 2.0;
      doubleArray6[1] = 0.0;
      doubleArray6[2] = 3138.168325;
      doubleArray6[3] = 0.0;
      doubleArray6[4] = 2.0;
      doubleArray6[5] = (-851.947634);
      doubleArray6[6] = 2460.510197234556;
      doubleArray6[7] = 2460.510197234556;
      doubleArray0[5] = doubleArray6;
      double[] doubleArray7 = new double[8];
      doubleArray7[0] = 0.0;
      doubleArray7[1] = 1.7976931348623157E308;
      doubleArray7[2] = 0.0;
      doubleArray7[3] = 395.9359308698316;
      doubleArray7[4] = 3138.168325;
      doubleArray7[5] = 395.9359308698316;
      doubleArray7[6] = 1794.63394275;
      doubleArray7[7] = (-2083.37);
      doubleArray0[6] = doubleArray7;
      double[] doubleArray8 = new double[5];
      doubleArray8[0] = 0.0;
      doubleArray8[1] = 3138.168325;
      doubleArray8[2] = 0.0;
      doubleArray8[3] = 2460.510197234556;
      doubleArray8[4] = 2.0;
      doubleArray0[7] = doubleArray8;
      double[] doubleArray9 = new double[9];
      doubleArray9[0] = 3138.168325;
      doubleArray9[1] = 0.0;
      doubleArray9[2] = 2808.287974275146;
      doubleArray9[3] = 0.0;
      doubleArray9[4] = 1794.63394275;
      doubleArray9[5] = 1140.36509;
      doubleArray9[6] = (-851.947634);
      doubleArray9[7] = 395.9359308698316;
      doubleArray9[8] = (-2083.37);
      doubleArray0[8] = doubleArray9;
      discretize0.m_CutPoints = doubleArray0;
      discretize0.getInvertSelection();
      discretize0.setMakeBinary(false);
      discretize0.m_UseBinNumbers = false;
      Filter.makeCopies(discretize0, 3512);
      discretize0.setUseEqualFrequency(false);
      discretize0.setUseEqualFrequency(false);
      Filter.makeCopies(discretize0, 3512);
      discretize0.desiredWeightOfInstancesPerIntervalTipText();
      discretize0.findNumBinsTipText();
      discretize0.getOptions();
      int int0 = 0;
      // Undeclared exception!
      try { 
        discretize0.calculateCutPointsByEqualWidthBinning(0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 8
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      assertNotNull(discretize0);
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.isNewBatch());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      
      // Undeclared exception!
      try { 
        discretize0.input((Instance) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No input instance format defined
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 9
  /*Coverage entropy=1.6094379124341005
  */
  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Discretize discretize0 = new Discretize("OAV4x1$~: D=WW:?");
      assertNotNull(discretize0);
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      
      String string0 = "pjgDj2%^u4@f.1yT^2";
      discretize0.setUseEqualFrequency(true);
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertTrue(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      
      Range range0 = new Range("pjgDj2%^u4@f.1yT^2");
      assertNotNull(range0);
      
      boolean boolean0 = range0.getInvert();
      assertFalse(boolean0);
      
      discretize0.m_DiscretizeCols = range0;
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertTrue(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      
      discretize0.m_FindNumBins = false;
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertTrue(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      
      String string1 = discretize0.invertSelectionTipText();
      assertNotNull(string1);
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertTrue(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", string1);
      assertFalse(string1.equals((Object)string0));
      
      discretize0.setUseEqualFrequency(false);
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      
      double double0 = (-144.0);
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (-144.0);
      doubleArray0[1] = (-144.0);
      discretize0.setUseBinNumbers(false);
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      
      int[] intArray0 = new int[1];
      intArray0[0] = 60;
      SparseInstance sparseInstance0 = null;
      try {
        sparseInstance0 = new SparseInstance((-144.0), doubleArray0, intArray0, 60);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("weka.core.SparseInstance", e);
      }
  }

  /**
  //Test case number: 10
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Discretize discretize0 = new Discretize("Make resulting attributes binary.");
      assertNotNull(discretize0);
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.isNewBatch());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      
      discretize0.m_NumBins = 170;
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.isNewBatch());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals(170, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      
      // Undeclared exception!
      try { 
        discretize0.batchFinished();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No input instance format defined
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 11
  /*Coverage entropy=3.178053830347946
  */
  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      assertNotNull(discretize0);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      
      String string0 = discretize0.getAttributeIndices();
      assertNotNull(string0);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("first-last", string0);
      
      String[] stringArray0 = new String[2];
      stringArray0[0] = "first-last";
      stringArray0[1] = "first-last";
      discretize0.setOptions(stringArray0);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals(2, stringArray0.length);
      
      int int0 = 98;
      double[] doubleArray0 = discretize0.getCutPoints(98);
      assertNull(doubleArray0);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      
      String string1 = discretize0.findNumBinsTipText();
      assertNotNull(string1);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", string1);
      assertFalse(string1.equals((Object)string0));
      
      String[] stringArray1 = discretize0.getOptions();
      assertNotNull(stringArray1);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertNotSame(stringArray1, stringArray0);
      assertEquals(6, stringArray1.length);
      assertFalse(stringArray1.equals((Object)stringArray0));
      
      Capabilities capabilities0 = discretize0.getCapabilities();
      assertNotNull(capabilities0);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(capabilities0.hasDependencies());
      assertEquals(0, capabilities0.getMinimumNumberInstances());
      
      String string2 = discretize0.invertSelectionTipText();
      assertNotNull(string2);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", string2);
      assertFalse(string2.equals((Object)string0));
      assertFalse(string2.equals((Object)string1));
      
      int int1 = (-1012);
      String string3 = discretize0.getBinRangesString((-1012));
      assertNull(string3);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize0.binsTipText());
      
      // Undeclared exception!
      try { 
        discretize0.getOutputFormat();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output format defined.
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  /**
  //Test case number: 12
  /*Coverage entropy=2.8133554045006157
  */
  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Discretize discretize0 = new Discretize(")s|Y)U-");
      assertNotNull(discretize0);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertEquals(10, discretize0.getBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      
      String string0 = discretize0.getAttributeIndices();
      assertNotNull(string0);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertEquals(10, discretize0.getBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals(")s|Y)U-", string0);
      
      discretize0.m_UseEqualFrequency = false;
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertEquals(10, discretize0.getBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      
      discretize0.m_MakeBinary = true;
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertEquals(10, discretize0.getBins());
      assertTrue(discretize0.getMakeBinary());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      
      discretize0.setInvertSelection(true);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertEquals(10, discretize0.getBins());
      assertTrue(discretize0.getMakeBinary());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      
      discretize0.setFindNumBins(true);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertEquals(10, discretize0.getBins());
      assertTrue(discretize0.getMakeBinary());
      assertTrue(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      
      discretize0.setBins(89);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals(89, discretize0.getBins());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertTrue(discretize0.getMakeBinary());
      assertTrue(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      
      int int0 = discretize0.getBins();
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals(89, discretize0.getBins());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertTrue(discretize0.getMakeBinary());
      assertTrue(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals(89, int0);
      
      String string1 = discretize0.attributeIndicesTipText();
      assertNotNull(string1);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals(89, discretize0.getBins());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertTrue(discretize0.getMakeBinary());
      assertTrue(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", string1);
      assertFalse(string1.equals((Object)string0));
      
      String string2 = discretize0.getBinRangesString(89);
      assertNull(string2);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals(89, discretize0.getBins());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertTrue(discretize0.getMakeBinary());
      assertTrue(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      
      String string3 = discretize0.makeBinaryTipText();
      assertNotNull(string3);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals(89, discretize0.getBins());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertTrue(discretize0.getMakeBinary());
      assertTrue(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Make resulting attributes binary.", string3);
      assertFalse(string3.equals((Object)string1));
      assertFalse(string3.equals((Object)string0));
      
      String[] stringArray0 = discretize0.getOptions();
      assertNotNull(stringArray0);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals(89, discretize0.getBins());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.isNewBatch());
      assertTrue(discretize0.getMakeBinary());
      assertTrue(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals(9, stringArray0.length);
  }

  /**
  //Test case number: 13
  /*Coverage entropy=1.6094379124341005
  */
  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Discretize discretize0 = new Discretize(")s|Y)U-");
      assertNotNull(discretize0);
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals(10, discretize0.getBins());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getMakeBinary());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = new Instances(")s|Y)U-", arrayList0, 1259);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(")s|Y)U-", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      
      Capabilities capabilities0 = discretize0.getCapabilities();
      assertNotNull(capabilities0);
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals(10, discretize0.getBins());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(capabilities0.hasDependencies());
      assertEquals(0, capabilities0.getMinimumNumberInstances());
      
      Discretize discretize1 = new Discretize("o<6)I1");
      assertNotNull(discretize1);
      assertFalse(discretize1.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize1.makeBinaryTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize1.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize1.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize1.ignoreClassTipText());
      assertFalse(discretize1.getUseBinNumbers());
      assertFalse(discretize1.isFirstBatchDone());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize1.findNumBinsTipText());
      assertEquals(10, discretize1.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize1.globalInfo());
      assertEquals((-1.0), discretize1.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize1.binsTipText());
      assertFalse(discretize1.getMakeBinary());
      assertFalse(discretize1.isOutputFormatDefined());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize1.invertSelectionTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize1.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize1.useBinNumbersTipText());
      assertFalse(discretize1.getIgnoreClass());
      assertFalse(discretize1.getFindNumBins());
      assertTrue(discretize1.isNewBatch());
      assertFalse(discretize1.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize1.equals((Object)discretize0));
      
      String string0 = discretize1.useBinNumbersTipText();
      assertNotNull(string0);
      assertFalse(discretize1.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize1.makeBinaryTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize1.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize1.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize1.ignoreClassTipText());
      assertFalse(discretize1.getUseBinNumbers());
      assertFalse(discretize1.isFirstBatchDone());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize1.findNumBinsTipText());
      assertEquals(10, discretize1.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize1.globalInfo());
      assertEquals((-1.0), discretize1.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Number of bins.", discretize1.binsTipText());
      assertFalse(discretize1.getMakeBinary());
      assertFalse(discretize1.isOutputFormatDefined());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize1.invertSelectionTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize1.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize1.useBinNumbersTipText());
      assertFalse(discretize1.getIgnoreClass());
      assertFalse(discretize1.getFindNumBins());
      assertTrue(discretize1.isNewBatch());
      assertFalse(discretize1.mayRemoveInstanceAfterFirstBatchDone());
      assertNotSame(discretize1, discretize0);
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", string0);
      assertFalse(discretize1.equals((Object)discretize0));
  }

  /**
  //Test case number: 14
  /*Coverage entropy=3.0910424533583143
  */
  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Discretize discretize0 = new Discretize(" \"3XB^u3'zgS");
      assertNotNull(discretize0);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      
      String[] stringArray0 = discretize0.getOptions();
      assertNotNull(stringArray0);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals(6, stringArray0.length);
      
      discretize0.setFindNumBins(false);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      
      Filter.runFilter(discretize0, stringArray0);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals(6, stringArray0.length);
      
      double[] doubleArray0 = discretize0.getCutPoints(3424);
      assertNull(doubleArray0);
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      
      discretize0.setOutputFormat();
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
  }

  /**
  //Test case number: 15
  /*Coverage entropy=2.2275247137250096
  */
  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Discretize discretize0 = new Discretize(":");
      assertNotNull(discretize0);
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      
      String[] stringArray0 = discretize0.getOptions();
      assertNotNull(stringArray0);
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getFindNumBins());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals(6, stringArray0.length);
      
      try { 
        discretize0.setInputFormat((Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  /**
  //Test case number: 16
  /*Coverage entropy=2.809539117005706
  */
  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      assertFalse(boolean0);
      
      Discretize discretize0 = new Discretize("");
      assertNotNull(discretize0);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      
      boolean boolean1 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      discretize0.m_FindNumBins = true;
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      
      discretize0.setDesiredWeightOfInstancesPerInterval((-2050));
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals((-2050.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      
      String[] stringArray0 = new String[0];
      Discretize.main(stringArray0);
      assertEquals(0, stringArray0.length);
      
      discretize0.m_UseBinNumbers = false;
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals((-2050.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      
      String string0 = discretize0.getBinRangesString((-2050));
      assertNull(string0);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals((-2050.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      
      String[] stringArray1 = discretize0.getOptions();
      assertNotNull(stringArray1);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals((-2050.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertNotSame(stringArray1, stringArray0);
      assertEquals(5, stringArray1.length);
      assertFalse(stringArray1.equals((Object)stringArray0));
      
      discretize0.setOptions(stringArray1);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals((-2050.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertNotSame(stringArray1, stringArray0);
      assertEquals(5, stringArray1.length);
      assertFalse(stringArray1.equals((Object)stringArray0));
      
      String[] stringArray2 = discretize0.getOptions();
      assertNotNull(stringArray2);
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals((-2050.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertNotSame(stringArray2, stringArray0);
      assertNotSame(stringArray2, stringArray1);
      assertEquals(5, stringArray2.length);
      assertFalse(stringArray2.equals((Object)stringArray0));
      assertFalse(stringArray2.equals((Object)stringArray1));
  }

  /**
  //Test case number: 17
  /*Coverage entropy=1.6094379124341005
  */
  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      assertNotNull(discretize0);
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      
      discretize0.m_MakeBinary = true;
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertTrue(discretize0.getMakeBinary());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      
      try { 
        discretize0.setInputFormat((Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  /**
  //Test case number: 18
  /*Coverage entropy=2.4036404106149494
  */
  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Discretize discretize0 = new Discretize();
      assertNotNull(discretize0);
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      
      discretize0.m_UseBinNumbers = true;
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertTrue(discretize0.getUseBinNumbers());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      
      Discretize discretize1 = (Discretize)Filter.makeCopy(discretize0);
      assertNotNull(discretize1);
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertTrue(discretize0.getUseBinNumbers());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize1.getFindNumBins());
      assertFalse(discretize1.getMakeBinary());
      assertEquals("Number of bins.", discretize1.binsTipText());
      assertFalse(discretize1.isOutputFormatDefined());
      assertFalse(discretize1.getIgnoreClass());
      assertFalse(discretize1.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(discretize1.getUseBinNumbers());
      assertEquals(10, discretize1.getBins());
      assertEquals("Make resulting attributes binary.", discretize1.makeBinaryTipText());
      assertFalse(discretize1.getUseEqualFrequency());
      assertTrue(discretize1.isNewBatch());
      assertEquals((-1.0), discretize1.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize1.globalInfo());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize1.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize1.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize1.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize1.attributeIndicesTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize1.useEqualFrequencyTipText());
      assertFalse(discretize1.isFirstBatchDone());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize1.invertSelectionTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize1.findNumBinsTipText());
      assertNotSame(discretize0, discretize1);
      assertNotSame(discretize1, discretize0);
      assertFalse(discretize1.equals((Object)discretize0));
      
      String[] stringArray0 = discretize0.getOptions();
      assertNotNull(stringArray0);
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertTrue(discretize0.getUseBinNumbers());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getMakeBinary());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertNotSame(discretize0, discretize1);
      assertEquals(7, stringArray0.length);
      assertFalse(discretize0.equals((Object)discretize1));
      
      // Undeclared exception!
      try { 
        discretize0.batchFinished();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // No input instance format defined
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 19
  /*Coverage entropy=1.0986122886681096
  */
  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      Discretize discretize0 = new Discretize();
      assertNotNull(discretize0);
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      
      double[][] doubleArray0 = new double[9][2];
      double[] doubleArray1 = new double[6];
      doubleArray1[0] = 0.0;
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 1739.8155945888;
      doubleArray1[3] = (-2176.18184943642);
      doubleArray1[4] = 0.0;
      doubleArray1[5] = 3505.4410971102;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[2];
      assertFalse(doubleArray2.equals((Object)doubleArray1));
      
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 1739.8155945888;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[4];
      assertFalse(doubleArray3.equals((Object)doubleArray2));
      assertFalse(doubleArray3.equals((Object)doubleArray1));
      
      doubleArray3[0] = 3505.4410971102;
      doubleArray3[1] = 0.0;
      doubleArray3[2] = 1739.8155945888;
      doubleArray3[3] = 1739.8155945888;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[4];
      assertFalse(doubleArray4.equals((Object)doubleArray1));
      assertFalse(doubleArray4.equals((Object)doubleArray2));
      assertFalse(doubleArray4.equals((Object)doubleArray3));
      
      doubleArray4[0] = (-2176.18184943642);
      doubleArray4[1] = (-2176.18184943642);
      doubleArray4[2] = 0.0;
      doubleArray4[3] = 0.0;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[9];
      assertFalse(doubleArray5.equals((Object)doubleArray1));
      assertFalse(doubleArray5.equals((Object)doubleArray2));
      assertFalse(doubleArray5.equals((Object)doubleArray4));
      assertFalse(doubleArray5.equals((Object)doubleArray3));
      
      doubleArray5[0] = 3505.4410971102;
      doubleArray5[1] = (-2176.18184943642);
      doubleArray5[2] = 0.0;
      doubleArray5[3] = (-2176.18184943642);
      doubleArray5[4] = 0.0;
      doubleArray5[5] = 0.0;
      doubleArray5[6] = (-2176.18184943642);
      doubleArray5[7] = 3505.4410971102;
      doubleArray5[8] = 3505.4410971102;
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[6];
      assertFalse(doubleArray6.equals((Object)doubleArray1));
      assertFalse(doubleArray6.equals((Object)doubleArray5));
      assertFalse(doubleArray6.equals((Object)doubleArray3));
      assertFalse(doubleArray6.equals((Object)doubleArray2));
      assertFalse(doubleArray6.equals((Object)doubleArray4));
      
      doubleArray6[0] = 0.0;
      doubleArray6[1] = 4.5;
      doubleArray6[2] = 0.0;
      doubleArray6[3] = (-2176.18184943642);
      doubleArray6[4] = 3505.4410971102;
      doubleArray6[5] = 0.0;
      doubleArray0[5] = doubleArray6;
      double[] doubleArray7 = new double[5];
      assertFalse(doubleArray7.equals((Object)doubleArray6));
      assertFalse(doubleArray7.equals((Object)doubleArray1));
      assertFalse(doubleArray7.equals((Object)doubleArray2));
      assertFalse(doubleArray7.equals((Object)doubleArray5));
      assertFalse(doubleArray7.equals((Object)doubleArray4));
      assertFalse(doubleArray7.equals((Object)doubleArray3));
      
      doubleArray7[0] = 0.0;
      doubleArray7[1] = 1739.8155945888;
      doubleArray7[2] = (-2176.18184943642);
      doubleArray7[3] = 3505.4410971102;
      doubleArray7[4] = 3505.4410971102;
      doubleArray0[6] = doubleArray7;
      double[] doubleArray8 = new double[7];
      assertFalse(doubleArray8.equals((Object)doubleArray3));
      assertFalse(doubleArray8.equals((Object)doubleArray7));
      assertFalse(doubleArray8.equals((Object)doubleArray5));
      assertFalse(doubleArray8.equals((Object)doubleArray1));
      assertFalse(doubleArray8.equals((Object)doubleArray4));
      assertFalse(doubleArray8.equals((Object)doubleArray2));
      assertFalse(doubleArray8.equals((Object)doubleArray6));
      
      doubleArray8[0] = 3505.4410971102;
      doubleArray8[1] = (-2176.18184943642);
      doubleArray8[2] = 3505.4410971102;
      doubleArray8[3] = 4.5;
      doubleArray8[4] = 4.5;
      doubleArray8[5] = 1739.8155945888;
      doubleArray8[6] = 1739.8155945888;
      doubleArray0[7] = doubleArray8;
      double[] doubleArray9 = new double[8];
      assertFalse(doubleArray9.equals((Object)doubleArray3));
      assertFalse(doubleArray9.equals((Object)doubleArray8));
      assertFalse(doubleArray9.equals((Object)doubleArray4));
      assertFalse(doubleArray9.equals((Object)doubleArray2));
      assertFalse(doubleArray9.equals((Object)doubleArray6));
      assertFalse(doubleArray9.equals((Object)doubleArray5));
      assertFalse(doubleArray9.equals((Object)doubleArray1));
      assertFalse(doubleArray9.equals((Object)doubleArray7));
      
      doubleArray9[0] = 0.0;
      doubleArray9[1] = 1739.8155945888;
      doubleArray9[2] = 0.0;
      doubleArray9[3] = 1739.8155945888;
      doubleArray9[4] = 0.0;
      doubleArray9[5] = 0.0;
      doubleArray9[6] = (-2176.18184943642);
      doubleArray9[7] = 0.0;
      doubleArray0[8] = doubleArray9;
      discretize0.m_CutPoints = doubleArray0;
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      
      // Undeclared exception!
      try { 
        discretize0.setOutputFormat();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 20
  /*Coverage entropy=3.0445224377234217
  */
  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      assertFalse(boolean0);
      
      Discretize discretize0 = new Discretize(" \"3XB^u3'zgS");
      assertNotNull(discretize0);
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getFindNumBins());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertFalse(discretize0.isFirstBatchDone());
      
      String[] stringArray0 = discretize0.getOptions();
      assertNotNull(stringArray0);
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getFindNumBins());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals(6, stringArray0.length);
      
      discretize0.setFindNumBins(false);
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getFindNumBins());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertFalse(discretize0.isFirstBatchDone());
      
      Filter.runFilter(discretize0, stringArray0);
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getFindNumBins());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals(6, stringArray0.length);
      
      double[][] doubleArray0 = new double[9][0];
      double[] doubleArray1 = new double[3];
      doubleArray1[0] = (-2415.169742893789);
      doubleArray1[1] = 0.0;
      doubleArray1[2] = 1575.41;
      doubleArray0[0] = doubleArray1;
      double[] doubleArray2 = new double[5];
      assertFalse(doubleArray2.equals((Object)doubleArray1));
      
      doubleArray2[0] = 0.0;
      doubleArray2[1] = 1575.41;
      doubleArray2[2] = 0.0;
      doubleArray2[3] = 1575.41;
      doubleArray2[4] = 1575.41;
      doubleArray0[1] = doubleArray2;
      double[] doubleArray3 = new double[8];
      assertFalse(doubleArray3.equals((Object)doubleArray1));
      assertFalse(doubleArray3.equals((Object)doubleArray2));
      
      doubleArray3[0] = 1575.41;
      doubleArray3[1] = 1575.41;
      doubleArray3[2] = 0.0;
      doubleArray3[3] = 0.0;
      doubleArray3[4] = 0.0;
      doubleArray3[5] = 0.0;
      doubleArray3[6] = 0.0;
      doubleArray3[7] = 0.0;
      doubleArray0[2] = doubleArray3;
      double[] doubleArray4 = new double[3];
      assertFalse(doubleArray4.equals((Object)doubleArray2));
      assertFalse(doubleArray4.equals((Object)doubleArray3));
      assertFalse(doubleArray4.equals((Object)doubleArray1));
      
      doubleArray4[0] = 0.0;
      doubleArray4[1] = 0.0;
      doubleArray4[2] = 2436.8;
      doubleArray0[3] = doubleArray4;
      double[] doubleArray5 = new double[2];
      assertFalse(doubleArray5.equals((Object)doubleArray4));
      assertFalse(doubleArray5.equals((Object)doubleArray2));
      assertFalse(doubleArray5.equals((Object)doubleArray1));
      assertFalse(doubleArray5.equals((Object)doubleArray3));
      
      doubleArray5[0] = 0.0;
      doubleArray5[1] = 1575.41;
      doubleArray0[4] = doubleArray5;
      double[] doubleArray6 = new double[6];
      assertFalse(doubleArray6.equals((Object)doubleArray3));
      assertFalse(doubleArray6.equals((Object)doubleArray5));
      assertFalse(doubleArray6.equals((Object)doubleArray4));
      assertFalse(doubleArray6.equals((Object)doubleArray1));
      assertFalse(doubleArray6.equals((Object)doubleArray2));
      
      doubleArray6[0] = 1575.41;
      doubleArray6[1] = 0.0;
      doubleArray6[2] = 0.0;
      doubleArray6[3] = 0.0;
      doubleArray6[4] = (-2415.169742893789);
      doubleArray6[5] = 0.0;
      doubleArray0[5] = doubleArray6;
      double[] doubleArray7 = new double[7];
      assertFalse(doubleArray7.equals((Object)doubleArray3));
      assertFalse(doubleArray7.equals((Object)doubleArray1));
      assertFalse(doubleArray7.equals((Object)doubleArray6));
      assertFalse(doubleArray7.equals((Object)doubleArray5));
      assertFalse(doubleArray7.equals((Object)doubleArray4));
      assertFalse(doubleArray7.equals((Object)doubleArray2));
      
      doubleArray7[0] = 151.20495842;
      doubleArray7[1] = 2436.8;
      doubleArray7[2] = 2436.8;
      doubleArray7[3] = 2436.8;
      doubleArray7[4] = 0.0;
      doubleArray7[5] = 0.0;
      doubleArray7[6] = (-2415.169742893789);
      doubleArray0[6] = doubleArray7;
      double[] doubleArray8 = new double[5];
      assertFalse(doubleArray8.equals((Object)doubleArray3));
      assertFalse(doubleArray8.equals((Object)doubleArray1));
      assertFalse(doubleArray8.equals((Object)doubleArray6));
      assertFalse(doubleArray8.equals((Object)doubleArray5));
      assertFalse(doubleArray8.equals((Object)doubleArray4));
      assertFalse(doubleArray8.equals((Object)doubleArray2));
      assertFalse(doubleArray8.equals((Object)doubleArray7));
      
      doubleArray8[0] = 0.0;
      doubleArray8[1] = 0.0;
      doubleArray8[2] = 2436.8;
      doubleArray8[3] = 0.0;
      doubleArray8[4] = 0.0;
      doubleArray0[7] = doubleArray8;
      double[] doubleArray9 = new double[4];
      assertFalse(doubleArray9.equals((Object)doubleArray1));
      assertFalse(doubleArray9.equals((Object)doubleArray7));
      assertFalse(doubleArray9.equals((Object)doubleArray8));
      assertFalse(doubleArray9.equals((Object)doubleArray2));
      assertFalse(doubleArray9.equals((Object)doubleArray3));
      assertFalse(doubleArray9.equals((Object)doubleArray6));
      assertFalse(doubleArray9.equals((Object)doubleArray5));
      assertFalse(doubleArray9.equals((Object)doubleArray4));
      
      doubleArray9[0] = 0.0;
      doubleArray9[1] = 2436.8;
      doubleArray9[2] = 0.0;
      doubleArray9[3] = 2436.8;
      doubleArray0[8] = doubleArray9;
      discretize0.m_CutPoints = doubleArray0;
      assertFalse(discretize0.getUseEqualFrequency());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals(10, discretize0.getBins());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.getFindNumBins());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertFalse(discretize0.isFirstBatchDone());
      
      // Undeclared exception!
      try { 
        discretize0.getCutPoints(3424);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 3424
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }

  /**
  //Test case number: 21
  /*Coverage entropy=2.5400363038209806
  */
  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      Discretize discretize0 = new Discretize("UY;p<f;]");
      assertNotNull(discretize0);
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertTrue(discretize0.isNewBatch());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals(10, discretize0.getBins());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getFindNumBins());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      
      discretize0.m_FindNumBins = true;
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertTrue(discretize0.isNewBatch());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals(10, discretize0.getBins());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.getFindNumBins());
      
      discretize0.setOutputFormat();
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertTrue(discretize0.isNewBatch());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getIgnoreClass());
      assertEquals(10, discretize0.getBins());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.getFindNumBins());
      
      SystemInUtil.addInputLine("UY;p<f;]");
      discretize0.setIgnoreClass(true);
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertTrue(discretize0.isNewBatch());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.getIgnoreClass());
      assertTrue(discretize0.getFindNumBins());
      
      String[] stringArray0 = discretize0.getOptions();
      assertNotNull(stringArray0);
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertTrue(discretize0.isNewBatch());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.getIgnoreClass());
      assertTrue(discretize0.getFindNumBins());
      assertEquals(8, stringArray0.length);
      
      discretize0.setOutputFormat();
      assertEquals("Sets the desired weight of instances per interval for equal-frequency binning.", discretize0.desiredWeightOfInstancesPerIntervalTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("The class index will be unset temporarily before the filter is applied.", discretize0.ignoreClassTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertTrue(discretize0.isNewBatch());
      assertEquals("An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by simple binning. Skips the class attribute if set.", discretize0.globalInfo());
      assertEquals((-1.0), discretize0.getDesiredWeightOfInstancesPerInterval(), 0.01);
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Optimize number of equal-width bins using leave-one-out. Doesn't work for equal-frequency binning", discretize0.findNumBinsTipText());
      assertEquals("If set to true, equal-frequency binning will be used instead of equal-width binning.", discretize0.useEqualFrequencyTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals(10, discretize0.getBins());
      assertEquals("Number of bins.", discretize0.binsTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getUseEqualFrequency());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.getIgnoreClass());
      assertTrue(discretize0.getFindNumBins());
      
      System.setCurrentTimeMillis(2L);
      int int0 = 2;
      // Undeclared exception!
      try { 
        discretize0.findNumBins(2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.unsupervised.attribute.Discretize", e);
      }
  }
}
